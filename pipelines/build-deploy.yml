name: $(date:yyyyMMdd)$(rev:.rr)

trigger:
  batch: true
  branches:
    include:
      - refs/heads/main
  paths:
    include:
      - requirements.txt
      - '*.spec'
      - main.py
      - ui/**
      - utils/**
      - screens/**
      - widgets/**

pr:
  branches:
    include:
      - main
  paths:
    include:
      - requirements.txt
      - main.py
      - ui/**
      - utils/**
      - screens/**
      - widgets/**

variables:
  - group: shared-variables
  - name: pythonVersion
    value: '3.12.10'
  - name: projectName
    value: 'NexusRFIDReader'
  - name: buildConfiguration
    value: 'Release'
  - name: storageAccountName
    value: 'sa{0}rfidlocate'
  - name: containerName
    value: 'deviceupdates'
  - name: workLoadServiceConnection
    value: 'spotlight-{0}-infrastructure-service-connection'

parameters:
  - name: environments
    type: object
    default:
      - name: Dev
        deployBranch: refs/heads/main
      - name: Test
        deployBranch: refs/heads/main
      - name: Prod
        deployBranch: refs/heads/main

stages:
  - stage: BuildProject
    displayName: 'Build and Package Stage'
    jobs:
      - job: MultiPlatformBuild
        displayName: 'Multi-Platform Build Job'
        strategy:
          matrix:
            Windows:
              vmImage: 'windows-latest'
              osName: 'Windows'
              executableSuffix: '.exe'
              pyinstallerOptions: '--onefile --windowed'
              hiddenImports: '--hidden-import=PySide6.QtCore --hidden-import=PySide6.QtWidgets --hidden-import=PySide6.QtGui --hidden-import=PySide6.QtOpenGL'
            Linux:
              vmImage: 'ubuntu-latest'
              osName: 'Linux'
              executableSuffix: ''
              pyinstallerOptions: '--onefile'
              hiddenImports: '--hidden-import=PySide6.QtCore --hidden-import=PySide6.QtWidgets --hidden-import=PySide6.QtGui'
            RaspberryPi:
              vmImage: 'ubuntu-latest'
              osName: 'RaspberryPi'
              executableSuffix: ''
              pyinstallerOptions: '--onefile'
              hiddenImports: '--hidden-import=PySide6.QtCore --hidden-import=PySide6.QtWidgets --hidden-import=PySide6.QtGui'
          maxParallel: 3

        pool:
          vmImage: $(vmImage)

        steps:
          # Checkout repository
          - checkout: self
            displayName: 'Checkout Repository'
            clean: true

          # Setup Python environment
          - task: UsePythonVersion@0
            displayName: 'Use Python $(pythonVersion)'
            inputs:
              versionSpec: '$(pythonVersion)'
              addToPath: true
              architecture: 'x64'

          # Install build dependencies
          - script: |
              python -m pip install --upgrade pip
              pip install setuptools wheel pyinstaller pytest
            displayName: 'Install Build Dependencies'

          # Install project dependencies
          - script: |
              pip install -r requirements.txt
            displayName: 'Install Project Dependencies'
            condition: succeeded()

          # Run tests - Windows PowerShell
          - task: PowerShell@2
            displayName: 'Run Tests (Windows)'
            condition: and(succeeded(), eq(variables['osName'], 'Windows'))
            continueOnError: true
            inputs:
              targetType: 'inline'
              script: |
                try {
                  if (Test-Path "tests") {
                    python -m pytest tests/ --junitxml="$(Agent.TempDirectory)/test-results.xml"
                    if ($LASTEXITCODE -ne 0) { Write-Host "Tests completed with issues" }
                  } elseif (Test-Path "UnitTests") {
                    python -m pytest UnitTests/ --junitxml="$(Agent.TempDirectory)/test-results.xml"
                    if ($LASTEXITCODE -ne 0) { Write-Host "Tests completed with issues" }
                  } else {
                    Write-Host "No tests directory found, creating empty test results"
                    New-Item -ItemType Directory -Path "$(Agent.TempDirectory)" -Force
                    $xmlContent = '<?xml version="1.0" encoding="UTF-8"?><testsuites><testsuite name="NoTests" tests="0" failures="0" errors="0" skipped="0"></testsuite></testsuites>'
                    Set-Content -Path "$(Agent.TempDirectory)/test-results.xml" -Value $xmlContent
                  }
                } catch {
                  Write-Host "Test execution failed: $($_.Exception.Message)"
                  Write-Host "Creating empty test results"
                  New-Item -ItemType Directory -Path "$(Agent.TempDirectory)" -Force
                  $xmlContent = '<?xml version="1.0" encoding="UTF-8"?><testsuites><testsuite name="NoTests" tests="0" failures="0" errors="0" skipped="0"></testsuite></testsuites>'
                  Set-Content -Path "$(Agent.TempDirectory)/test-results.xml" -Value $xmlContent
                }
          
          # Run tests - Linux/Mac Bash
          - bash: |
              if [ -d "tests" ]; then
                python -m pytest tests/ --junitxml=$(Agent.TempDirectory)/test-results.xml || echo "Tests completed with issues"
              elif [ -d "UnitTests" ]; then
                python -m pytest UnitTests/ --junitxml=$(Agent.TempDirectory)/test-results.xml || echo "Tests completed with issues"
              else
                echo "No tests directory found, creating empty test results"
                mkdir -p $(Agent.TempDirectory)
                echo '<?xml version="1.0" encoding="UTF-8"?><testsuites><testsuite name="NoTests" tests="0" failures="0" errors="0" skipped="0"></testsuite></testsuites>' > $(Agent.TempDirectory)/test-results.xml
              fi
            displayName: 'Run Tests (Linux)'
            condition: and(succeeded(), ne(variables['osName'], 'Windows'))
            continueOnError: true

          # Publish test results
          - task: PublishTestResults@2
            displayName: 'Publish Test Results'
            inputs:
              testResultsFiles: '$(Agent.TempDirectory)/test-results.xml'
              testRunTitle: '$(osName) Test Results'
              failTaskOnFailedTests: false
            condition: always()

          # Build with PyInstaller - Windows
          - task: PowerShell@2
            displayName: 'Build Executable (Windows)'
            condition: and(succeeded(), eq(variables['osName'], 'Windows'))
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Building for $(osName)..."
                New-Item -ItemType Directory -Path "$(Build.ArtifactStagingDirectory)/$(osName)" -Force
                
                if (Test-Path "$(projectName).spec") {
                  pyinstaller $(projectName).spec --clean --noconfirm --distpath "$(Build.ArtifactStagingDirectory)/$(osName)"
                } else {
                  if (!(Test-Path "main.py")) { Write-Error "main.py not found"; exit 1 }
                  $pyinstallerArgs = @(
                    "main.py", "--name", "$(projectName)",
                    "$(pyinstallerOptions)".Split(' '), "$(hiddenImports)".Split(' '),
                    "--add-data", "font;font", "--add-data", "ui;ui",
                    "--add-data", "screens;screens", "--add-data", "utils;utils",
                    "--add-data", "widgets;widgets", "--clean", "--noconfirm",
                    "--distpath", "$(Build.ArtifactStagingDirectory)/$(osName)",
                    "--workpath", "$(Agent.TempDirectory)/build",
                    "--specpath", "$(Agent.TempDirectory)/spec"
                  )
                  & pyinstaller $pyinstallerArgs
                }
          
          # Build with PyInstaller - Linux
          - bash: |
              echo "Building for $(osName)..."
              mkdir -p $(Build.ArtifactStagingDirectory)/$(osName)
              
              if [ -f "$(projectName).spec" ]; then
                pyinstaller $(projectName).spec --clean --noconfirm --distpath $(Build.ArtifactStagingDirectory)/$(osName)
              else
                if [ ! -f "main.py" ]; then echo "main.py not found"; exit 1; fi
                pyinstaller main.py \
                  --name $(projectName) $(pyinstallerOptions) $(hiddenImports) \
                  --add-data "font:font" --add-data "ui:ui" \
                  --add-data "screens:screens" --add-data "utils:utils" \
                  --add-data "widgets:widgets" --clean --noconfirm \
                  --distpath $(Build.ArtifactStagingDirectory)/$(osName) \
                  --workpath $(Agent.TempDirectory)/build \
                  --specpath $(Agent.TempDirectory)/spec
              fi
            displayName: 'Build Executable (Linux)'
            condition: and(succeeded(), ne(variables['osName'], 'Windows'))

          # Verify Build - Windows
          - task: PowerShell@2
            displayName: 'Verify Build (Windows)'
            condition: and(succeeded(), eq(variables['osName'], 'Windows'))
            inputs:
              targetType: 'inline'
              script: |
                if (Test-Path "$(Build.ArtifactStagingDirectory)/$(osName)/$(projectName).exe") {
                  Write-Host "✅ Executable found"
                } else {
                  Write-Host "❌ Executable NOT found"; exit 1
                }
          
          # Verify Build - Linux
          - bash: |
              if [ -f "$(Build.ArtifactStagingDirectory)/$(osName)/$(projectName)" ]; then
                echo "✅ Executable found"
                chmod +x "$(Build.ArtifactStagingDirectory)/$(osName)/$(projectName)"
              else
                echo "❌ Executable NOT found"; exit 1
              fi
            displayName: 'Verify Build (Linux)'
            condition: and(succeeded(), ne(variables['osName'], 'Windows'))

          # Create release package
          - task: ArchiveFiles@2
            displayName: 'Create Release Package'
            inputs:
              rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/$(osName)'
              includeRootFolder: true
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/$(projectName)-$(osName)-$(Build.BuildNumber).zip'
              replaceExistingArchive: true
            condition: succeeded()

          # Publish artifacts for deployment stages
          - task: PublishPipelineArtifact@1
            displayName: 'Publish $(osName) Artifacts'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/$(osName)'
              artifactName: '$(projectName)-$(osName)-artifacts'
              publishLocation: 'pipeline'
            condition: succeeded()

          # Publish release package
          - task: PublishPipelineArtifact@1
            displayName: 'Publish $(osName) Release Package'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/$(projectName)-$(osName)-$(Build.BuildNumber).zip'
              artifactName: '$(projectName)-$(osName)-$(Build.BuildNumber)'
              publishLocation: 'pipeline'
            condition: succeeded()

  # Post-build stage for release notes
  - stage: PostBuild
    displayName: 'Post-Build Activities'
    dependsOn: BuildProject
    condition: succeeded()
    jobs:
      - job: GenerateReleaseNotes
        displayName: 'Generate Release Notes'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - script: |
              echo "=== NexusRFIDReader Build $(Build.BuildNumber) Release Notes ===" > $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "**Build Information:**" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Build Number: $(Build.BuildNumber)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Build Date: $(date)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Source Branch: $(Build.SourceBranch)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Source Version: $(Build.SourceVersion)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "**Supported Platforms:**" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Windows (GUI mode)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Linux (Console mode)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Raspberry Pi (Console mode)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "**Deployment Environments:**" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- DEV: sadevrf idlocate/deviceupdates/builds/$(Build.BuildNumber)/" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- TEST: satestrf idlocate/deviceupdates/builds/$(Build.BuildNumber)/" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- PROD: saprodrf idlocate/deviceupdates/builds/$(Build.BuildNumber)/" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "**OTA Update Version:** $(Build.BuildNumber)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
            displayName: 'Generate Release Notes'
            
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Release Notes'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md'
              artifactName: 'ReleaseNotes-$(Build.BuildNumber)'
              publishLocation: 'pipeline'

  # Deploy to DEV
  - stage: DeployDev
    displayName: Deploy to DEV
    lockBehavior: runLatest
    dependsOn:
      - BuildProject
      - PostBuild
    condition: succeeded()
    jobs:
      - deployment: DeployToBlobStorage
        displayName: Deploy artifacts to DEV Blob Storage
        continueOnError: false
        environment:
          name: dev
        variables:
          - group: dev-variables
          - group: dev-keyvault-secrets
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Windows Artifacts'
                  inputs:
                    artifact: '$(projectName)-Windows-artifacts'
                    path: '$(Pipeline.Workspace)/Windows'

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Linux Artifacts'
                  inputs:
                    artifact: '$(projectName)-Linux-artifacts'
                    path: '$(Pipeline.Workspace)/Linux'

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download RaspberryPi Artifacts'
                  inputs:
                    artifact: '$(projectName)-RaspberryPi-artifacts'
                    path: '$(Pipeline.Workspace)/RaspberryPi'

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Packages'
                  inputs:
                    artifact: '$(projectName)-Windows-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/packages'

                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-Linux-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/packages'

                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-RaspberryPi-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/packages'

                - task: AzureFileCopy@6
                  displayName: 'Upload Windows to DEV'
                  inputs:
                    SourcePath: '$(Pipeline.Workspace)/Windows/$(projectName).exe'
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'dev') }}
                    Destination: 'AzureBlob'
                    storage: ${{ format(variables.storageAccountName, 'dev') }}
                    ContainerName: '$(containerName)'
                    BlobPrefix: 'builds/$(Build.BuildNumber)/Windows/'

                - task: AzureFileCopy@6
                  displayName: 'Upload Windows Package to DEV'
                  inputs:
                    SourcePath: '$(Pipeline.Workspace)/packages/$(projectName)-Windows-$(Build.BuildNumber).zip'
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'dev') }}
                    Destination: 'AzureBlob'
                    storage: ${{ format(variables.storageAccountName, 'dev') }}
                    ContainerName: '$(containerName)'
                    BlobPrefix: 'releases/$(Build.BuildNumber)/'

                - task: AzureCLI@2
                  displayName: 'Upload Linux/RaspberryPi to DEV'
                  inputs:
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'dev') }}
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      S="${{ format(variables.storageAccountName, 'dev') }}"
                      C="$(containerName)"
                      B="$(Build.BuildNumber)"
                      P="$(projectName)"
                      
                      az storage blob upload --file "$(Pipeline.Workspace)/Linux/$P" --name "builds/$B/Linux/$P" \
                        --container-name "$C" --account-name "$S" --auth-mode login --overwrite
                      az storage blob upload --file "$(Pipeline.Workspace)/packages/$P-Linux-$B.zip" --name "releases/$B/$P-Linux-$B.zip" \
                        --container-name "$C" --account-name "$S" --auth-mode login --overwrite
                      az storage blob upload --file "$(Pipeline.Workspace)/RaspberryPi/$P" --name "builds/$B/RaspberryPi/$P" \
                        --container-name "$C" --account-name "$S" --auth-mode login --overwrite
                      az storage blob upload --file "$(Pipeline.Workspace)/packages/$P-RaspberryPi-$B.zip" --name "releases/$B/$P-RaspberryPi-$B.zip" \
                        --container-name "$C" --account-name "$S" --auth-mode login --overwrite

                - task: AzureCLI@2
                  displayName: 'Verify DEV Uploads'
                  inputs:
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'dev') }}
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      S="${{ format(variables.storageAccountName, 'dev') }}"
                      C="$(containerName)"
                      for B in "builds/$(Build.BuildNumber)/Windows/$(projectName).exe" \
                               "builds/$(Build.BuildNumber)/Linux/$(projectName)" \
                               "builds/$(Build.BuildNumber)/RaspberryPi/$(projectName)"; do
                        az storage blob exists --account-name "$S" --container-name "$C" --name "$B" --auth-mode login --output tsv | grep -q "True" && echo "✅ $B" || (echo "❌ $B"; exit 1)
                      done

  # Deploy to TEST
  - stage: DeployTest
    displayName: Deploy to TEST
    lockBehavior: runLatest
    dependsOn:
      - BuildProject
      - PostBuild
    condition: succeeded()
    jobs:
      - deployment: DeployToBlobStorage
        displayName: Deploy artifacts to TEST Blob Storage
        continueOnError: false
        environment:
          name: test
        variables:
          - group: test-variables
          - group: test-keyvault-secrets
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none
                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Artifacts'
                  inputs:
                    artifact: '$(projectName)-Windows-artifacts'
                    path: '$(Pipeline.Workspace)/Windows'
                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-Linux-artifacts'
                    path: '$(Pipeline.Workspace)/Linux'
                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-RaspberryPi-artifacts'
                    path: '$(Pipeline.Workspace)/RaspberryPi'
                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-Windows-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/packages'
                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-Linux-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/packages'
                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-RaspberryPi-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/packages'
                - task: AzureFileCopy@6
                  displayName: 'Upload Windows to TEST'
                  inputs:
                    SourcePath: '$(Pipeline.Workspace)/Windows/$(projectName).exe'
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'test') }}
                    Destination: 'AzureBlob'
                    storage: ${{ format(variables.storageAccountName, 'test') }}
                    ContainerName: '$(containerName)'
                    BlobPrefix: 'builds/$(Build.BuildNumber)/Windows/'
                - task: AzureFileCopy@6
                  displayName: 'Upload Windows Package to TEST'
                  inputs:
                    SourcePath: '$(Pipeline.Workspace)/packages/$(projectName)-Windows-$(Build.BuildNumber).zip'
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'test') }}
                    Destination: 'AzureBlob'
                    storage: ${{ format(variables.storageAccountName, 'test') }}
                    ContainerName: '$(containerName)'
                    BlobPrefix: 'releases/$(Build.BuildNumber)/'
                - task: AzureCLI@2
                  displayName: 'Upload Linux/RaspberryPi to TEST'
                  inputs:
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'test') }}
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      S="${{ format(variables.storageAccountName, 'test') }}"
                      C="$(containerName)"
                      B="$(Build.BuildNumber)"
                      P="$(projectName)"
                      az storage blob upload --file "$(Pipeline.Workspace)/Linux/$P" --name "builds/$B/Linux/$P" --container-name "$C" --account-name "$S" --auth-mode login --overwrite
                      az storage blob upload --file "$(Pipeline.Workspace)/packages/$P-Linux-$B.zip" --name "releases/$B/$P-Linux-$B.zip" --container-name "$C" --account-name "$S" --auth-mode login --overwrite
                      az storage blob upload --file "$(Pipeline.Workspace)/RaspberryPi/$P" --name "builds/$B/RaspberryPi/$P" --container-name "$C" --account-name "$S" --auth-mode login --overwrite
                      az storage blob upload --file "$(Pipeline.Workspace)/packages/$P-RaspberryPi-$B.zip" --name "releases/$B/$P-RaspberryPi-$B.zip" --container-name "$C" --account-name "$S" --auth-mode login --overwrite
                - task: AzureCLI@2
                  displayName: 'Verify TEST Uploads'
                  inputs:
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'test') }}
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      S="${{ format(variables.storageAccountName, 'test') }}"
                      C="$(containerName)"
                      for B in "builds/$(Build.BuildNumber)/Windows/$(projectName).exe" "builds/$(Build.BuildNumber)/Linux/$(projectName)" "builds/$(Build.BuildNumber)/RaspberryPi/$(projectName)"; do
                        az storage blob exists --account-name "$S" --container-name "$C" --name "$B" --auth-mode login --output tsv | grep -q "True" && echo "✅ $B" || (echo "❌ $B"; exit 1)
                      done

  # Deploy to PROD
  - stage: DeployProd
    displayName: Deploy to PROD
    lockBehavior: runLatest
    dependsOn:
      - BuildProject
      - PostBuild
    condition: succeeded()
    jobs:
      - deployment: DeployToBlobStorage
        displayName: Deploy artifacts to PROD Blob Storage
        continueOnError: false
        environment:
          name: prod
        variables:
          - group: prod-keyvault-secrets
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none
                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Artifacts'
                  inputs:
                    artifact: '$(projectName)-Windows-artifacts'
                    path: '$(Pipeline.Workspace)/Windows'
                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-Linux-artifacts'
                    path: '$(Pipeline.Workspace)/Linux'
                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-RaspberryPi-artifacts'
                    path: '$(Pipeline.Workspace)/RaspberryPi'
                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-Windows-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/packages'
                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-Linux-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/packages'
                - task: DownloadPipelineArtifact@2
                  inputs:
                    artifact: '$(projectName)-RaspberryPi-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/packages'
                - task: AzureFileCopy@6
                  displayName: 'Upload Windows to PROD'
                  inputs:
                    SourcePath: '$(Pipeline.Workspace)/Windows/$(projectName).exe'
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'prod') }}
                    Destination: 'AzureBlob'
                    storage: ${{ format(variables.storageAccountName, 'prod') }}
                    ContainerName: '$(containerName)'
                    BlobPrefix: 'builds/$(Build.BuildNumber)/Windows/'
                - task: AzureFileCopy@6
                  displayName: 'Upload Windows Package to PROD'
                  inputs:
                    SourcePath: '$(Pipeline.Workspace)/packages/$(projectName)-Windows-$(Build.BuildNumber).zip'
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'prod') }}
                    Destination: 'AzureBlob'
                    storage: ${{ format(variables.storageAccountName, 'prod') }}
                    ContainerName: '$(containerName)'
                    BlobPrefix: 'releases/$(Build.BuildNumber)/'
                - task: AzureCLI@2
                  displayName: 'Upload Linux/RaspberryPi to PROD'
                  inputs:
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'prod') }}
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      S="${{ format(variables.storageAccountName, 'prod') }}"
                      C="$(containerName)"
                      B="$(Build.BuildNumber)"
                      P="$(projectName)"
                      az storage blob upload --file "$(Pipeline.Workspace)/Linux/$P" --name "builds/$B/Linux/$P" --container-name "$C" --account-name "$S" --auth-mode login --overwrite
                      az storage blob upload --file "$(Pipeline.Workspace)/packages/$P-Linux-$B.zip" --name "releases/$B/$P-Linux-$B.zip" --container-name "$C" --account-name "$S" --auth-mode login --overwrite
                      az storage blob upload --file "$(Pipeline.Workspace)/RaspberryPi/$P" --name "builds/$B/RaspberryPi/$P" --container-name "$C" --account-name "$S" --auth-mode login --overwrite
                      az storage blob upload --file "$(Pipeline.Workspace)/packages/$P-RaspberryPi-$B.zip" --name "releases/$B/$P-RaspberryPi-$B.zip" --container-name "$C" --account-name "$S" --auth-mode login --overwrite
                - task: AzureCLI@2
                  displayName: 'Verify PROD Uploads'
                  inputs:
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'prod') }}
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      S="${{ format(variables.storageAccountName, 'prod') }}"
                      C="$(containerName)"
                      for B in "builds/$(Build.BuildNumber)/Windows/$(projectName).exe" "builds/$(Build.BuildNumber)/Linux/$(projectName)" "builds/$(Build.BuildNumber)/RaspberryPi/$(projectName)"; do
                        az storage blob exists --account-name "$S" --container-name "$C" --name "$B" --auth-mode login --output tsv | grep -q "True" && echo "✅ $B" || (echo "❌ $B"; exit 1)
                      done
