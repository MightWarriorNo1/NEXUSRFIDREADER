name: $(date:yyyyMMdd)$(rev:.rr)

trigger:
  batch: true
  branches:
    include:
      - refs/heads/main
  paths:
    include:
      - requirements.txt
      - '*.spec'
      - main.py
      - ui/**
      - utils/**
      - screens/**
      - widgets/**

pr:
  branches:
    include:
      - main
  paths:
    include:
      - requirements.txt
      - main.py
      - ui/**
      - utils/**
      - screens/**
      - widgets/**

variables:
  - group: shared-variables
  - name: pythonVersion
    value: '3.12.10'
  - name: projectName
    value: 'NexusRFIDReader'
  - name: buildConfiguration
    value: 'Release'
  - name: storageAccountName
    value: 'sa{0}rfidlocate'
  - name: containerName
    value: 'deviceupdates'
  - name: workLoadServiceConnection
    value: 'spotlight-{0}-infrastructure-service-connection'

parameters:
  - name: environments
    type: object
    default:
      - name: Dev
        deployBranch: refs/heads/main
      - name: Test
        deployBranch: refs/heads/main
      - name: Prod
        deployBranch: refs/heads/main

stages:
  - stage: BuildProject
    displayName: 'Build and Package Stage'
    condition: succeeded()
    jobs:
      - job: MultiPlatformBuild
        displayName: 'Multi-Platform Build Job'
        strategy:
          matrix:
            Linux:
              vmImage: 'ubuntu-latest'
              osName: 'Linux'
              executableSuffix: ''
              pyinstallerOptions: '--onefile'
              hiddenImports: '--hidden-import=PySide6.QtCore --hidden-import=PySide6.QtWidgets --hidden-import=PySide6.QtGui'
            RaspberryPi:
              vmImage: 'ubuntu-latest'
              osName: 'RaspberryPi'
              executableSuffix: ''
              pyinstallerOptions: '--onefile'
              hiddenImports: '--hidden-import=PySide6.QtCore --hidden-import=PySide6.QtWidgets --hidden-import=PySide6.QtGui'
          maxParallel: 2

        pool:
          vmImage: $(vmImage)

        steps:
          # Checkout repository
          - checkout: self
            displayName: 'Checkout Repository'
            clean: true

          # Setup Python environment
          - task: UsePythonVersion@0
            displayName: 'Use Python $(pythonVersion)'
            inputs:
              versionSpec: '$(pythonVersion)'
              addToPath: true
              architecture: 'x64'

          # Install build dependencies
          - script: |
              python -m pip install --upgrade pip
              pip install setuptools wheel pyinstaller pytest
            displayName: 'Install Build Dependencies'

          # Install project dependencies
          - script: |
              pip install -r requirements.txt
            displayName: 'Install Project Dependencies'
            condition: succeeded()

          # Run tests - Linux/RaspberryPi
          - bash: |
              if [ -d "tests" ]; then
                python -m pytest tests/ --junitxml=$(Agent.TempDirectory)/test-results.xml
                if [ $? -ne 0 ]; then
                  echo "##vso[task.logissue type=error]Tests failed with exit code $?"
                  exit $?
                fi
              elif [ -d "UnitTests" ]; then
                python -m pytest UnitTests/ --junitxml=$(Agent.TempDirectory)/test-results.xml
                if [ $? -ne 0 ]; then
                  echo "##vso[task.logissue type=error]Tests failed with exit code $?"
                  exit $?
                fi
              else
                echo "No tests directory found, creating empty test results"
                mkdir -p $(Agent.TempDirectory)
                echo '<?xml version="1.0" encoding="UTF-8"?><testsuites><testsuite name="NoTests" tests="0" failures="0" errors="0" skipped="0"></testsuite></testsuites>' > $(Agent.TempDirectory)/test-results.xml
              fi
            displayName: 'Run Tests (Linux/RaspberryPi)'
            condition: succeeded()

          # Publish test results
          - task: PublishTestResults@2
            displayName: 'Publish Test Results'
            inputs:
              testResultsFiles: '$(Agent.TempDirectory)/test-results.xml'
              testRunTitle: '$(osName) Test Results'
              failTaskOnFailedTests: false
            condition: always()

          # Build with PyInstaller - Linux/RaspberryPi
          - bash: |
              echo "Building for $(osName)..."
              mkdir -p $(Agent.TempDirectory)/dist
              
              if [ -f "$(projectName).spec" ]; then
                pyinstaller $(projectName).spec --clean --noconfirm --distpath $(Agent.TempDirectory)/dist
              else
                if [ ! -f "main.py" ]; then echo "main.py not found"; exit 1; fi
                pyinstaller main.py \
                  --name $(projectName) $(pyinstallerOptions) $(hiddenImports) \
                  --add-data "font:font" --add-data "ui:ui" \
                  --add-data "screens:screens" --add-data "utils:utils" \
                  --add-data "widgets:widgets" --clean --noconfirm \
                  --distpath $(Agent.TempDirectory)/dist \
                  --workpath $(Agent.TempDirectory)/build \
                  --specpath $(Agent.TempDirectory)/spec
              fi
              
              # Verify executable was created
              if [ ! -f "$(Agent.TempDirectory)/dist/$(projectName)" ]; then
                echo "ERROR: Executable not created successfully"
                exit 1
              fi
              chmod +x "$(Agent.TempDirectory)/dist/$(projectName)"
              echo "✅ Executable built successfully"
            displayName: 'Build Executable (Linux/RaspberryPi)'
            condition: succeeded()

          # Create .deb package for Linux/RaspberryPi
          - bash: |
              set -euo pipefail
              echo "Creating .deb package for $(osName)..."
              
              # Ensure dpkg-deb is available
              if ! command -v dpkg-deb &> /dev/null; then
                echo "Installing dpkg-dev package..."
                sudo apt-get update -qq
                sudo apt-get install -y dpkg-dev
              fi
              
              PACKAGE_NAME="$(projectName)"
              PACKAGE_VERSION="$(Build.BuildNumber)"
              ARCHITECTURE=$(dpkg --print-architecture 2>/dev/null || echo "amd64")
              echo "Detected architecture: $ARCHITECTURE"
              DESCRIPTION="Nexus RFID Reader - Advanced RFID scanning and GPS tracking system"
              MAINTAINER="Nexus Systems"
              WEBSITE="https://nexusyms.com"
              
              # Create package directory structure
              PKG_DIR="${PACKAGE_NAME}-${PACKAGE_VERSION}"
              mkdir -p ${PKG_DIR}/DEBIAN
              mkdir -p ${PKG_DIR}/usr/local/bin
              mkdir -p ${PKG_DIR}/usr/share/applications
              mkdir -p ${PKG_DIR}/usr/share/icons/hicolor/512x512/apps
              mkdir -p ${PKG_DIR}/etc/systemd/system
              mkdir -p ${PKG_DIR}/var/lib/nexusrfid
              
              # Copy executable
              cp $(Agent.TempDirectory)/dist/${PACKAGE_NAME} ${PKG_DIR}/usr/local/bin/
              
              # Copy icon if it exists
              if [ -f "ui/img/icon.ico" ]; then
                cp ui/img/icon.ico ${PKG_DIR}/usr/share/icons/hicolor/512x512/apps/${PACKAGE_NAME}.ico
              fi
              
              # Create systemd service file (with placeholders)
              cat > ${PKG_DIR}/etc/systemd/system/nexusrfid_production.service <<'EOL'
              [Unit]
              Description=Nexus RFID Application
              After=graphical.target
              Wants=graphical.target
              
              [Service]
              Type=simple
              ExecStartPre=/bin/bash -c '/usr/bin/sudo /sbin/dhclient usb0 || true'
              ExecStartPre=/bin/sleep 5
              ExecStart=sudo /usr/local/bin/NexusRFIDReader
              Restart=always
              RestartSec=5
              User=__SERVICE_USER__
              Environment=PYTHONUNBUFFERED=1
              Environment=DISPLAY=:0
              Environment=XAUTHORITY=__XAUTHORITY_PATH__
              Environment=HOME=__HOME_DIR__
              Environment=XDG_RUNTIME_DIR=__XDG_RUNTIME_DIR__
              Environment=DBUS_SESSION_BUS_ADDRESS=__DBUS_SESSION_BUS_ADDRESS__
              
              [Install]
              WantedBy=graphical.target
              EOL
              
              # Create .desktop file
              cat > ${PKG_DIR}/usr/share/applications/${PACKAGE_NAME}.desktop <<EOL
              [Desktop Entry]
              Version=1.0
              Name=Nexus RFID Reader
              Comment=Advanced RFID scanning and GPS tracking system
              Exec=/usr/local/bin/${PACKAGE_NAME}
              Icon=${PACKAGE_NAME}
              Terminal=false
              Type=Application
              Categories=Utility;Office;
              Keywords=RFID;GPS;Inventory;Tracking;
              StartupNotify=true
              EOL
              
              # Create control file
              cat > ${PKG_DIR}/DEBIAN/control <<EOL
              Package: ${PACKAGE_NAME}
              Version: ${PACKAGE_VERSION}
              Section: utils
              Priority: optional
              Architecture: ${ARCHITECTURE}
              Maintainer: ${MAINTAINER} <support@nexusyms.com>
              Homepage: ${WEBSITE}
              Depends: libxcb-xinerama0, libxcb-cursor0, libx11-xcb1, libxcb1, libxfixes3, libxi6, libxrender1, libxcb-render0, libxcb-shape0, libxcb-xfixes0, x11-xserver-utils, python3, python3-pip, systemd, sudo, isc-dhcp-client, sed, arp-scan
              Description: ${DESCRIPTION}
               This application provides advanced RFID scanning capabilities with GPS tracking,
               real-time data processing, and cloud synchronization. It's designed for inventory
               management and asset tracking in industrial environments.
               .
               Features:
                * Real-time RFID tag scanning
                * GPS location tracking
                * SQLite database storage
                * Cloud API integration
                * Configurable filtering options
                * Automatic data synchronization
                * User-friendly GUI interface
                * Systemd service for automatic startup and monitoring
              EOL
              
              # Create postinst script
              cat > ${PKG_DIR}/DEBIAN/postinst <<'EOL'
              #!/bin/bash
              set -e
              
              echo "Setting up NexusRFIDReader environment..."
              
              # Determine the user to run the service
              SERVICE_USER=""
              
              if [ -n "${SUDO_USER:-}" ]; then
                  SERVICE_USER="$SUDO_USER"
                  echo "Detected installation user: $SERVICE_USER"
              elif [ -n "${USER:-}" ] && [ "$USER" != "root" ]; then
                  SERVICE_USER="$USER"
                  echo "Detected current user: $SERVICE_USER"
              else
                  if [ -d "/home/pi" ] && id "pi" &>/dev/null; then
                      SERVICE_USER="pi"
                      echo "Detected Raspberry Pi default user: pi"
                  else
                      for user_dir in /home/*; do
                          if [ -d "$user_dir" ]; then
                              user_name=$(basename "$user_dir")
                              if id "$user_name" &>/dev/null; then
                                  SERVICE_USER="$user_name"
                                  echo "Detected user from home directory: $SERVICE_USER"
                                  break
                              fi
                          fi
                      done
                  fi
              fi
              
              if [ -z "$SERVICE_USER" ]; then
                  if command -v who &>/dev/null; then
                      DISPLAY_USER=$(who | awk '/\(:0\)/ {print $1; exit}')
                      if [ -n "$DISPLAY_USER" ] && id "$DISPLAY_USER" &>/dev/null; then
                          SERVICE_USER="$DISPLAY_USER"
                          echo "Detected user from X session: $SERVICE_USER"
                      fi
                  fi
              fi
              
              if [ -z "$SERVICE_USER" ]; then
                  SERVICE_USER=$(getent passwd | awk -F: '$3 >= 1000 && $1 != "nobody" {print $1; exit}')
                  if [ -n "$SERVICE_USER" ]; then
                      echo "Using first non-root user: $SERVICE_USER"
                  fi
              fi
              
              if [ -z "$SERVICE_USER" ] || ! id "$SERVICE_USER" &>/dev/null; then
                  echo "ERROR: Could not determine a valid user for the service."
                  echo "Please create a user account or specify one manually."
                  echo "You can edit /etc/systemd/system/nexusrfid_production.service after installation."
                  exit 1
              fi
              
              echo "Using user for service: $SERVICE_USER"
              
              SERVICE_UID=$(id -u "$SERVICE_USER")
              SERVICE_HOME=$(eval echo ~"$SERVICE_USER")
              SERVICE_XAUTHORITY="${SERVICE_HOME}/.Xauthority"
              SERVICE_XDG_RUNTIME_DIR="/run/user/${SERVICE_UID}"
              SERVICE_DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/${SERVICE_UID}/bus"
              
              # Configure sudo for dhclient
              SUDOERS_FILE="/etc/sudoers.d/nexusrfid"
              NEED_SUDO_CONFIG=true
              
              if [ -f "$SUDOERS_FILE" ]; then
                  if grep -q "^${SERVICE_USER}.*NOPASSWD.*dhclient" "$SUDOERS_FILE" 2>/dev/null; then
                      NEED_SUDO_CONFIG=false
                      echo "Sudo configuration for $SERVICE_USER already exists"
                  fi
              fi
              
              if [ "$NEED_SUDO_CONFIG" = true ]; then
                  echo "Configuring sudo permissions for $SERVICE_USER user..."
                  {
                      echo "${SERVICE_USER} ALL=(ALL) NOPASSWD: /sbin/dhclient"
                      echo "${SERVICE_USER} ALL=(ALL) NOPASSWD: /usr/sbin/dhclient"
                  } > "$SUDOERS_FILE"
                  chmod 0440 "$SUDOERS_FILE"
                  echo "Sudo configuration added for dhclient"
              fi
              
              # Create data directory
              RFID_DATA_DIR=/var/lib/nexusrfid
              if [ ! -d "$RFID_DATA_DIR" ]; then
                  mkdir -p "$RFID_DATA_DIR"
                  echo "Created data directory at $RFID_DATA_DIR"
              fi
              
              chown "${SERVICE_USER}:${SERVICE_USER}" "$RFID_DATA_DIR"
              chmod 755 "$RFID_DATA_DIR"
              
              # Ensure X11 permissions
              if [ -d "$SERVICE_HOME" ]; then
                  if [ ! -f "$SERVICE_XAUTHORITY" ]; then
                      touch "$SERVICE_XAUTHORITY" 2>/dev/null || true
                  fi
                  if [ -f "$SERVICE_XAUTHORITY" ]; then
                      chown "${SERVICE_USER}:${SERVICE_USER}" "$SERVICE_XAUTHORITY" 2>/dev/null || true
                      chmod 600 "$SERVICE_XAUTHORITY" 2>/dev/null || true
                  fi
                  chown -R "${SERVICE_USER}:${SERVICE_USER}" "$SERVICE_HOME" 2>/dev/null || true
              fi
              
              # Update service file with user information
              SERVICE_FILE="/etc/systemd/system/nexusrfid_production.service"
              if [ -f "$SERVICE_FILE" ]; then
                  echo "Configuring service file with user information..."
                  sed -i "s|__SERVICE_USER__|${SERVICE_USER}|g" "$SERVICE_FILE"
                  sed -i "s|__XAUTHORITY_PATH__|${SERVICE_XAUTHORITY}|g" "$SERVICE_FILE"
                  sed -i "s|__HOME_DIR__|${SERVICE_HOME}|g" "$SERVICE_FILE"
                  sed -i "s|__XDG_RUNTIME_DIR__|${SERVICE_XDG_RUNTIME_DIR}|g" "$SERVICE_FILE"
                  sed -i "s|__DBUS_SESSION_BUS_ADDRESS__|${SERVICE_DBUS_SESSION_BUS_ADDRESS}|g" "$SERVICE_FILE"
                  echo "Service file configured successfully"
              fi
              
              # Reload systemd and enable service
              systemctl daemon-reload
              systemctl enable nexusrfid_production.service
              echo "Service enabled to start on boot"
              
              # Update desktop database and icon cache
              if command -v update-desktop-database &> /dev/null; then
                  update-desktop-database /usr/share/applications
              fi
              if command -v gtk-update-icon-cache &> /dev/null; then
                  gtk-update-icon-cache -f -t /usr/share/icons/hicolor
              fi
              
              echo "NexusRFIDReader installation completed successfully!"
              EOL
              chmod 0755 ${PKG_DIR}/DEBIAN/postinst
              
              # Create prerm script
              cat > ${PKG_DIR}/DEBIAN/prerm <<'EOL'
              #!/bin/bash
              echo "Stopping NexusRFIDReader service..."
              if systemctl is-active --quiet nexusrfid_production.service 2>/dev/null; then
                  systemctl stop nexusrfid_production.service
                  echo "Service stopped"
              fi
              if systemctl is-enabled --quiet nexusrfid_production.service 2>/dev/null; then
                  systemctl disable nexusrfid_production.service
                  echo "Service disabled"
              fi
              systemctl daemon-reload
              pkill -f "NexusRFIDReader" || true
              echo "NexusRFIDReader service stopped and disabled."
              EOL
              chmod 0755 ${PKG_DIR}/DEBIAN/prerm
              
              # Create postrm script
              cat > ${PKG_DIR}/DEBIAN/postrm <<'EOL'
              #!/bin/bash
              if [ -f "/etc/sudoers.d/nexusrfid" ]; then
                  rm -f /etc/sudoers.d/nexusrfid
                  echo "Removed sudo configuration"
              fi
              systemctl daemon-reload 2>/dev/null || true
              echo "Cleanup completed."
              EOL
              chmod 0755 ${PKG_DIR}/DEBIAN/postrm
              
              # Build the .deb package
              dpkg-deb --build ${PKG_DIR}
              
              # Move package to artifact staging directory
              mkdir -p $(Build.ArtifactStagingDirectory)/$(osName)
              mv ${PKG_DIR}.deb $(Build.ArtifactStagingDirectory)/$(osName)/${PACKAGE_NAME}-${PACKAGE_VERSION}-${ARCHITECTURE}.deb
              
              # Clean up
              rm -rf ${PKG_DIR}
              
              echo "✅ .deb package created successfully"
            displayName: 'Create .deb Package (Linux/RaspberryPi)'
            condition: succeeded()

          # Publish .deb package
          - task: PublishPipelineArtifact@1
            displayName: 'Publish $(osName) Package (.deb)'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/$(osName)'
              artifactName: '$(projectName)-$(osName)-$(Build.BuildNumber)'
              publishLocation: 'pipeline'
            condition: succeeded()

  # Post-build stage for release notes
  - stage: PostBuild
    displayName: 'Post-Build Activities'
    dependsOn: BuildProject
    condition: succeeded()
    jobs:
      - job: GenerateReleaseNotes
        displayName: 'Generate Release Notes'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - script: |
              echo "=== NexusRFIDReader Build $(Build.BuildNumber) Release Notes ===" > $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "**Build Information:**" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Build Number: $(Build.BuildNumber)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Build Date: $(date)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Source Branch: $(Build.SourceBranch)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Source Version: $(Build.SourceVersion)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "**Supported Platforms:**" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Linux (Console mode)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- Raspberry Pi (Console mode)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "**Deployment Environments:**" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- DEV: sadevrf idlocate/deviceupdates/builds/$(Build.BuildNumber)/" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- TEST: satestrf idlocate/deviceupdates/builds/$(Build.BuildNumber)/" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "- PROD: saprodrf idlocate/deviceupdates/builds/$(Build.BuildNumber)/" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
              echo "**OTA Update Version:** $(Build.BuildNumber)" >> $(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md
            displayName: 'Generate Release Notes'

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Release Notes'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/RELEASE_NOTES.md'
              artifactName: 'ReleaseNotes-$(Build.BuildNumber)'
              publishLocation: 'pipeline'

  # Deploy to DEV
  - stage: DeployDev
    displayName: Deploy to DEV
    lockBehavior: runLatest
    dependsOn:
      - BuildProject
      - PostBuild
    condition: succeeded()
    jobs:
      - deployment: DeployToBlobStorage
        displayName: Deploy artifacts to DEV Blob Storage
        continueOnError: false
        environment:
          name: dev
        variables:
          - group: dev-variables
          - group: dev-keyvault-secrets
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Linux Package'
                  inputs:
                    artifact: '$(projectName)-Linux-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/Linux'

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download RaspberryPi Package'
                  inputs:
                    artifact: '$(projectName)-RaspberryPi-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/RaspberryPi'

                - task: AzureCLI@2
                  displayName: 'Upload to storage account'
                  inputs:
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'dev') }}
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -euo pipefail
                      SA="${{ format(variables.storageAccountName, 'dev') }}"
                      CN="deviceupdates"
                      SAS="$(rfidstoragesasRW)"
                      BUILD="$(Build.BuildNumber)"
                      
                      # Upload executables to builds/{build_number}/{osName}/
                      az storage blob upload-batch \
                        --account-name "$SA" \
                        --destination "$CN" \
                        --destination-path "builds/$BUILD/Linux" \
                        --source "$(Pipeline.Workspace)/Linux" \
                        --sas-token "$SAS" \
                        --overwrite
                      
                      az storage blob upload-batch \
                        --account-name "$SA" \
                        --destination "$CN" \
                        --destination-path "builds/$BUILD/RaspberryPi" \
                        --source "$(Pipeline.Workspace)/RaspberryPi" \
                        --sas-token "$SAS" \
                        --overwrite
                      
                      # Upload release packages to releases/{build_number}/
                      P="$(projectName)"
                      
                      # Linux .deb package
                      LINUX_DEB=$(find "$(Pipeline.Workspace)/Linux" -type f -name "$P-$BUILD-*.deb" 2>/dev/null | head -1)
                      if [ -n "$LINUX_DEB" ] && [ -f "$LINUX_DEB" ]; then
                        DEB_NAME=$(basename "$LINUX_DEB")
                        echo "Uploading Linux .deb package: $DEB_NAME"
                        az storage blob upload \
                          --account-name "$SA" \
                          --container-name "$CN" \
                          --name "releases/$BUILD/$DEB_NAME" \
                          --file "$LINUX_DEB" \
                          --sas-token "$SAS" \
                          --overwrite
                      else
                        echo "WARNING: Linux .deb package not found in $(Pipeline.Workspace)/Linux"
                      fi
                      
                      # RaspberryPi .deb package
                      RPI_DEB=$(find "$(Pipeline.Workspace)/RaspberryPi" -type f -name "$P-$BUILD-*.deb" 2>/dev/null | head -1)
                      if [ -n "$RPI_DEB" ] && [ -f "$RPI_DEB" ]; then
                        DEB_NAME=$(basename "$RPI_DEB")
                        echo "Uploading RaspberryPi .deb package: $DEB_NAME"
                        az storage blob upload \
                          --account-name "$SA" \
                          --container-name "$CN" \
                          --name "releases/$BUILD/$DEB_NAME" \
                          --file "$RPI_DEB" \
                          --sas-token "$SAS" \
                          --overwrite
                      else
                        echo "WARNING: RaspberryPi .deb package not found in $(Pipeline.Workspace)/RaspberryPi"
                      fi

  # Deploy to TEST
  - stage: DeployTest
    displayName: Deploy to TEST
    lockBehavior: runLatest
    dependsOn:
      - DeployDev
    condition: succeeded()
    jobs:
      - deployment: DeployToBlobStorage
        displayName: Deploy artifacts to TEST Blob Storage
        continueOnError: false
        environment:
          name: test
        variables:
          - group: test-variables
          - group: test-keyvault-secrets
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Linux Package'
                  inputs:
                    artifact: '$(projectName)-Linux-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/Linux'

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download RaspberryPi Package'
                  inputs:
                    artifact: '$(projectName)-RaspberryPi-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/RaspberryPi'

                - task: AzureCLI@2
                  displayName: 'Upload to storage account'
                  inputs:
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'test') }}
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -euo pipefail
                      SA="${{ format(variables.storageAccountName, 'test') }}"
                      CN="deviceupdates"
                      SAS="$(rfidstoragesasRW)"
                      BUILD="$(Build.BuildNumber)"
                      P="$(projectName)"
                      
                      echo "=== Debug Information ==="
                      echo "Storage Account: $SA"
                      echo "Container: $CN"
                      echo "Build Number: $BUILD"
                      echo "Project Name: $P"
                      echo ""
                      
                      # Debug: List contents of downloaded directories
                      echo "=== Contents of Linux directory ==="
                      ls -la "$(Pipeline.Workspace)/Linux" || echo "Linux directory not found or empty"
                      echo ""
                      echo "=== Contents of RaspberryPi directory ==="
                      ls -la "$(Pipeline.Workspace)/RaspberryPi" || echo "RaspberryPi directory not found or empty"
                      echo ""
                      
                      # Upload .deb packages to builds/{build_number}/{osName}/
                      # Linux .deb package
                      LINUX_DEB=$(find "$(Pipeline.Workspace)/Linux" -type f -name "*.deb" 2>/dev/null | head -1)
                      if [ -n "$LINUX_DEB" ] && [ -f "$LINUX_DEB" ]; then
                        DEB_NAME=$(basename "$LINUX_DEB")
                        echo "Found Linux .deb package: $DEB_NAME"
                        echo "Uploading to builds/$BUILD/Linux/$DEB_NAME"
                        az storage blob upload \
                          --account-name "$SA" \
                          --container-name "$CN" \
                          --name "builds/$BUILD/Linux/$DEB_NAME" \
                          --file "$LINUX_DEB" \
                          --sas-token "$SAS" \
                          --overwrite
                        echo "✅ Linux package uploaded to builds/"
                      else
                        echo "ERROR: Linux .deb package not found in $(Pipeline.Workspace)/Linux"
                        exit 1
                      fi
                      
                      # RaspberryPi .deb package
                      RPI_DEB=$(find "$(Pipeline.Workspace)/RaspberryPi" -type f -name "*.deb" 2>/dev/null | head -1)
                      if [ -n "$RPI_DEB" ] && [ -f "$RPI_DEB" ]; then
                        DEB_NAME=$(basename "$RPI_DEB")
                        echo "Found RaspberryPi .deb package: $DEB_NAME"
                        echo "Uploading to builds/$BUILD/RaspberryPi/$DEB_NAME"
                        az storage blob upload \
                          --account-name "$SA" \
                          --container-name "$CN" \
                          --name "builds/$BUILD/RaspberryPi/$DEB_NAME" \
                          --file "$RPI_DEB" \
                          --sas-token "$SAS" \
                          --overwrite
                        echo "✅ RaspberryPi package uploaded to builds/"
                      else
                        echo "ERROR: RaspberryPi .deb package not found in $(Pipeline.Workspace)/RaspberryPi"
                        exit 1
                      fi
                      
                      # Upload release packages to releases/{build_number}/
                      echo ""
                      echo "=== Uploading to releases/ ==="
                      LINUX_DEB=$(find "$(Pipeline.Workspace)/Linux" -type f -name "*.deb" 2>/dev/null | head -1)
                      if [ -n "$LINUX_DEB" ] && [ -f "$LINUX_DEB" ]; then
                        DEB_NAME=$(basename "$LINUX_DEB")
                        echo "Uploading Linux .deb package to releases: $DEB_NAME"
                        az storage blob upload \
                          --account-name "$SA" \
                          --container-name "$CN" \
                          --name "releases/$BUILD/$DEB_NAME" \
                          --file "$LINUX_DEB" \
                          --sas-token "$SAS" \
                          --overwrite
                        echo "✅ Linux package uploaded to releases/"
                      else
                        echo "ERROR: Linux .deb package not found for releases upload"
                        exit 1
                      fi
                      
                      RPI_DEB=$(find "$(Pipeline.Workspace)/RaspberryPi" -type f -name "*.deb" 2>/dev/null | head -1)
                      if [ -n "$RPI_DEB" ] && [ -f "$RPI_DEB" ]; then
                        DEB_NAME=$(basename "$RPI_DEB")
                        echo "Uploading RaspberryPi .deb package to releases: $DEB_NAME"
                        az storage blob upload \
                          --account-name "$SA" \
                          --container-name "$CN" \
                          --name "releases/$BUILD/$DEB_NAME" \
                          --file "$RPI_DEB" \
                          --sas-token "$SAS" \
                          --overwrite
                        echo "✅ RaspberryPi package uploaded to releases/"
                      else
                        echo "ERROR: RaspberryPi .deb package not found for releases upload"
                        exit 1
                      fi
                      
                      echo ""
                      echo "✅ All uploads completed successfully"

  # Deploy to PROD
  - stage: DeployProd
    displayName: Deploy to PROD
    lockBehavior: runLatest
    dependsOn:
      - DeployTest
    condition: succeeded()
    jobs:
      - deployment: DeployToBlobStorage
        displayName: Deploy artifacts to PROD Blob Storage
        continueOnError: false
        environment:
          name: prod
        variables:
          - group: prod-keyvault-secrets
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Linux Package'
                  inputs:
                    artifact: '$(projectName)-Linux-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/Linux'

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download RaspberryPi Package'
                  inputs:
                    artifact: '$(projectName)-RaspberryPi-$(Build.BuildNumber)'
                    path: '$(Pipeline.Workspace)/RaspberryPi'

                - task: AzureCLI@2
                  displayName: 'Upload to storage account'
                  inputs:
                    azureSubscription: ${{ format(variables.workLoadServiceConnection, 'prod') }}
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -euo pipefail
                      SA="${{ format(variables.storageAccountName, 'prod') }}"
                      CN="deviceupdates"
                      SAS="$(rfidstoragesasRW)"
                      BUILD="$(Build.BuildNumber)"
                      
                      # Upload executables to builds/{build_number}/{osName}/
                      az storage blob upload-batch \
                        --account-name "$SA" \
                        --destination "$CN" \
                        --destination-path "builds/$BUILD/Linux" \
                        --source "$(Pipeline.Workspace)/Linux" \
                        --sas-token "$SAS" \
                        --overwrite
                      
                      az storage blob upload-batch \
                        --account-name "$SA" \
                        --destination "$CN" \
                        --destination-path "builds/$BUILD/RaspberryPi" \
                        --source "$(Pipeline.Workspace)/RaspberryPi" \
                        --sas-token "$SAS" \
                        --overwrite
                      
                      # Upload release packages to releases/{build_number}/
                      P="$(projectName)"
                      
                      # Linux .deb package
                      LINUX_DEB=$(find "$(Pipeline.Workspace)/Linux" -type f -name "$P-$BUILD-*.deb" 2>/dev/null | head -1)
                      if [ -n "$LINUX_DEB" ] && [ -f "$LINUX_DEB" ]; then
                        DEB_NAME=$(basename "$LINUX_DEB")
                        echo "Uploading Linux .deb package: $DEB_NAME"
                        az storage blob upload \
                          --account-name "$SA" \
                          --container-name "$CN" \
                          --name "releases/$BUILD/$DEB_NAME" \
                          --file "$LINUX_DEB" \
                          --sas-token "$SAS" \
                          --overwrite
                      else
                        echo "WARNING: Linux .deb package not found in $(Pipeline.Workspace)/Linux"
                      fi
                      
                      # RaspberryPi .deb package
                      RPI_DEB=$(find "$(Pipeline.Workspace)/RaspberryPi" -type f -name "$P-$BUILD-*.deb" 2>/dev/null | head -1)
                      if [ -n "$RPI_DEB" ] && [ -f "$RPI_DEB" ]; then
                        DEB_NAME=$(basename "$RPI_DEB")
                        echo "Uploading RaspberryPi .deb package: $DEB_NAME"
                        az storage blob upload \
                          --account-name "$SA" \
                          --container-name "$CN" \
                          --name "releases/$BUILD/$DEB_NAME" \
                          --file "$RPI_DEB" \
                          --sas-token "$SAS" \
                          --overwrite
                      else
                        echo "WARNING: RaspberryPi .deb package not found in $(Pipeline.Workspace)/RaspberryPi"
                      fi
